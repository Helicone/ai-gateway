create table public.helicone_api_keys (
  created_at timestamp with time zone not null default now(),
  api_key_hash text not null,
  api_key_name text not null,
  user_id uuid not null,
  id bigint generated by default as identity not null,
  soft_delete boolean not null default false,
  organization_id uuid not null,
  key_permissions text null default 'w'::text,
  temp_key boolean not null default false,
  governance boolean not null default false,
  updated_at timestamp with time zone not null default null,
  constraint helicone_api_keys_pkey primary key (api_key_hash, id),
  constraint helicone_api_keys_id_key unique (id),
  constraint helicone_api_keys_organization_id_fkey foreign KEY (organization_id) references organization (id)
) TABLESPACE pg_default;

CREATE OR REPLACE FUNCTION broadcast_cloud_key_change() RETURNS trigger AS $$
BEGIN
  PERFORM pg_notify(
    'connected_cloud_gateways',           -- channel
    json_build_object(
      'event', 'api_key_updated',
      'organization_id', COALESCE(NEW.organization_id, OLD.organization_id),
      'api_key_hash', COALESCE(NEW.api_key_hash, OLD.api_key_hash),
      'owner_id', COALESCE(NEW.user_id, OLD.user_id),
      'op', TG_OP
    )::text
  );
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

create trigger t_connected_cloud_gateways_broadcast_keys
after INSERT
or DELETE
or
update on helicone_api_keys for EACH row
execute FUNCTION broadcast_cloud_key_change ();

CREATE OR REPLACE FUNCTION broadcast_key_change() RETURNS trigger AS $$
BEGIN
  PERFORM pg_notify(
    'connected_gateways',           -- channel
    json_build_object(
      'event', 'api_key_updated',
      'organization_id', COALESCE(NEW.organization_id, OLD.organization_id),
      'api_key_id', COALESCE(NEW.id, OLD.id),
      'op', TG_OP
    )::text
  );
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;


create trigger t_connected_gateways_broadcast
after INSERT
or DELETE
or
update on helicone_api_keys for EACH row
execute FUNCTION broadcast_key_change ();